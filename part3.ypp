%{
    #include "part3.hpp"
    #include <stdio.h>
    using namespace std;
    
    extern char *yytext;
    extern int yylex();
    extern int yylineno;
    void yyerror(char const * message);
	
    ParserNode* parseTree = NULL;
    
%}

%token id str integernum realnum 
%token tk_int tk_float tk_void tk_write tk_read tk_while tk_do tk_return tk_activate tk_scope tk_scopes
%nonassoc tk_if tk_then
%nonassoc tk_else
%left tk_comma
%right tk_assign
%left tk_or
%left tk_and
%left relop
%left addop
%left mulop
%right tk_not 
%left tk_dot
%left tk_rp '{'
%right tk_lp '}'

%%


PROGRAM:    FDEFS   						{parseTree = makeNode("PROGRAM",NULL, $1);}  ;

FDEFS:      FDEFS FUNC_API BLK  				{$$ = makeNode("FDEFS",NULL, $1);
                                				concatList($1, $2);
                                				concatList($1, $3);}   |
            FDEFS FUNC_API ';'  				{$$ = makeNode("FDEFS",NULL, $1);
                                				concatList($1, $2);
                                				concatList($1, $3);}   |
                                				{$$ = makeNode("FDEFS",NULL,makeNode("EPSILON",NULL, NULL));};
            
FUNC_API:   TYPE id tk_lp FUNC_ARGS tk_rp SCOPES_API    	{$$ = makeNode("FUNC_API",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5);
                                                                concatList($1, $6); }; 

SCOPES_API: 	tk_dot tk_scopes tk_lp SCOPES_LIST tk_rp    	{$$ = makeNode("SCOPES_API",NULL, $1);
                                                            	concatList($1, $2);
                                                            	concatList($1, $3);
                                                            	concatList($1, $4);
                                                            	concatList($1, $5);}    | 
                                                            	{$$ = makeNode("SCOPES_API",NULL,makeNode("EPSILON",NULL, NULL));};
            
FUNC_ARGS:  	FUNC_ARGLIST    				{$$ = makeNode("FUNC_ARGS",NULL, $1);}|
                            					{$$ = makeNode("FUNC_ARGS",NULL,makeNode("EPSILON",NULL, NULL));};

FUNC_ARGLIST: 	FUNC_ARGLIST tk_comma DCL  			{$$ = makeNode("FUNC_ARGLIST",NULL, $1);
                                    				concatList($1, $2);
                                    				concatList($1, $3);}    |
              	DCL                   				{$$ = makeNode("FUNC_ARGLIST",NULL, $1);};
              
BLK: 	'{' STLIST '}'                 				{$$ = makeNode("BLK",NULL, $1);
                                    				concatList($1, $2);
                                    				concatList($1, $3);}    ;

DCL:    id ':' TYPE                 				            {$$ =

                                                                }    |
        id tk_comma DCL             				{$$ = makeNode("DCL",NULL, $1);
                                    				concatList($1, $2);
                                    				concatList($1, $3);}    ; 
                                    
TYPE:   tk_int     						                        { $$ = makeNode("TYPE",NULL, $1); }    |
        tk_float   						                        { $$ = makeNode("TYPE",NULL, $1); }    |
        tk_void    						                        { $$ = makeNode("TYPE",NULL, $1); }    ;
        
STLIST: STLIST STMT 						                    { $$ = makeNode("STLIST",NULL, $1);
                                                                concatList($1, $2);}    |
                                                                {$$ = makeNode("STLIST",NULL,makeNode("EPSILON",NULL, NULL));};
        
STMT:   DCL ';'     						                    {
                                                                $$ = makeNode("STMT",NULL, $1);
                                                                concatList($1, $2);}                |
        ASSN        						                    { $$ = makeNode("STMT",NULL, $1); }   |
        EXP ';'     						                    {
                                                                $$ = makeNode("STMT",NULL, $1);
                                                                concatList($1, $2);}                  |
        CNTRL       						                    { $$ = makeNode("STMT",NULL, $1); }   |
        READ        						                    { $$ = makeNode("STMT",NULL, $1); }   |
        WRITE       						                    { $$ = makeNode("STMT",NULL, $1); }   |
        RETURN      						                    { $$ = makeNode("STMT",NULL, $1); }   |
        BLK         						                    { $$ = makeNode("STMT",NULL, $1); }   |
        tk_scope tk_lp integernum tk_rp BLK    			        {
                                                                $$ = makeNode("STMT",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5);};
        
RETURN: tk_return EXP ';'   					                {
                                                                $$ = makeNode("RETURN",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3); }    |
        tk_return ';'       					                {
                                                                $$ = makeNode("RETURN",NULL, $1);
                                                                concatList($1, $2); }    ;
        
WRITE:  tk_write tk_lp EXP tk_rp ';'    			            {
                                                                $$ = makeNode("WRITE",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5); }    |

        tk_write tk_lp str tk_rp ';'    			            {
                                                                $$ = makeNode("WRITE",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5); }    ;
        
READ:   tk_read tk_lp LVAL tk_rp ';'    			            {
                                                                $$ = makeNode("READ",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5); }    ;
        
ASSN:   LVAL tk_assign EXP ';'      				            {
                                                                $$ = makeNode("ASSN",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4); }    ;
        
LVAL:   id                                                  	{ $$ = makeNode("LVAL",NULL, $1); }   ;
	
CNTRL:  tk_if BEXP tk_then M STMT N tk_else M STMT          	{
                                                            	commands->backpatch($2.truelist , $4.quad) ;
                                                            	commands->backpatch($2.falselist , $8.quad) ;
                                                            	$$.nextlist = Commands::merge($5.nextlist, $7.nextlist, $9.nextlist);
                                                            	}   |

        tk_if BEXP tk_then M STMT                           	{
                                                            	commands->backpatch($2.truelist , $4.quad ) ;
                                                            	$$.nextlist = Commands::merge ( $2.falselist, $5.nextlist );
                                                            	}    |
                                                                                                        
        tk_while M BEXP tk_do M STMT                        	{
                                                            	commands->backpatch($6.nextlist, $2.quad) ;
                                                            	commands->backpatch($3.truelist , $5.quad) } ;
                                                            	$$.nextlist = $3.falselist ;
                                                            	commands->emit ( 'UJUMP ' + $2.quad); };

BEXP:   BEXP tk_or M BEXP     					                {
																commands->backpatch($1.falselist, $3.quad);
																$$.truelist = commands->merge($1.truelist, $4.truelist);
																$$.falselist = $4.falselist ; 
																}  |
    	BEXP tk_and M BEXP    					                {
																commands->backpatch($1.truelist, $3.quad);
																$$.falselist = commands->merge($1.truelist, $4.truelist);
																$$.truelist = $4.falselist ; 
																}  |

    	tk_not BEXP         					                {
                                                                $$.truelist = $2.falselist ; 
																$$.falselist = $2.truelist ; 
                                                                }  |

    	EXP relop EXP       					                {
                                                                $$.truelist = commands->makelist(commands->nextquad());
																TODO: complete
																}  |

    	tk_lp BEXP tk_rp        				                {
                                                                $$.truelist = $2.truelist ; 
																$$.falselist = $2.falselist ;  
																} ;
        
EXP:    EXP addop EXP       					                
		{
			int reg1, reg2;
			// both are integers:
			if($1.type == INT && $3.type == INT){
				$$.type = INT;
				reg1 = $1.regnum;
				reg2 = $3.regnum;
				// no casting is needed
			// both are floats:
			} else if($1.type == FLOAT && $3.type == FLOAT){
				$$.type = FLOAT;
				reg1 = $1.regnum;
				reg2 = $3.regnum;
				// no casting is needed
			} else{ // one is integer and the other is float
				$$.type = FLOAT;
				if($1.type == INT){ // first is integer
					reg1 = RegisterIdx[FLOAT]++;
					commands->emit("CITOF " + "I" + to_string($1.regnum) + "F" + to_string(reg1));
					reg2 = $3.regnum;
				} else{ // second is integer
					reg2 = RegisterIdx[FLOAT]++;
					commands->emit("CITOF " + "I" + to_string($3.regnum) + "F" + to_string(reg2));
					reg1 = $1.regnum;
				}
			}
			
			// allocate register for parent
			$$.regnum = RegisterIdx[$$.type];
			// different operation kind based on type:
			string op_type;
			if($$.type == INT){
				op_type = "I"
			} else{
				op_type = "F"
			}
			
			if($2.value == "+"){ // addition
				commands->emit("ADD2" + op_type + " " + op_type + to_string($$.regnum) + " " + op_type + to_string(reg1) + " " + op_type + to_string(reg2));
			} else{ // subtraction
				commands->emit("SUBT" + op_type + " " + op_type + to_string($$.regnum) + " " + op_type + to_string(reg1) + " " + op_type + to_string(reg2));
			}
				
		}	|
		
        EXP mulop EXP       					                
		{
			int reg1, reg2;
			// both are integers:
			if($1.type == INT && $3.type == INT){
				$$.type = INT;
				reg1 = $1.regnum;
				reg2 = $3.regnum;
				// no casting is needed
			// both are floats:
			} else if($1.type == FLOAT && $3.type == FLOAT){
				$$.type = FLOAT;
				reg1 = $1.regnum;
				reg2 = $3.regnum;
				// no casting is needed
			} else{ // one is integer and the other is float
				$$.type = FLOAT;
				if($1.type == INT){ // first is integer
					reg1 = RegisterIdx[FLOAT]++;
					commands->emit("CITOF " + "I" + to_string($1.regnum) + "F" + to_string(reg1));
					reg2 = $3.regnum;
				} else{ // second is integer
					reg2 = RegisterIdx[FLOAT]++;
					commands->emit("CITOF " + "I" + to_string($3.regnum) + "F" + to_string(reg2));
					reg1 = $1.regnum;
				}
			}
			
			// allocate register for parent
			$$.regnum = RegisterIdx[$$.type];
			// different operation kind based on type:
			string op_type = ($$.type == INT) ? "I" : "F";
			
			if($2.value == "*"){ // multiplication
				commands->emit("MULT" + op_type + " " + op_type + to_string($$.regnum) + " " + op_type + to_string(reg1) + " " + op_type + to_string(reg2));
			} else{ // division
				commands->emit("DIVD" + op_type + " " + op_type + to_string($$.regnum) + " " + op_type + to_string(reg1) + " " + op_type + to_string(reg2));
			}
	
		}  |

        tk_lp EXP tk_rp         				                
		{
			$$.type = $2.type;
			$$.regnum = $2.regnum;
			
		}  |

        tk_lp TYPE tk_rp EXP    				                
		{
			$$.type = ($2.type == "int") ? INT : FLOAT;
			$$.regnum = RegisterIdx[$$.type]++;
			string op_type = ($$.type == INT) ? "I" : "F";
			emit("COPY" + op_type + " " + op_type + to_string($$.regnum) + " " + op_type + to_string($4.regnum));
		}  |

        id              					                    
		{ 
			
		}  |

        NUM             					                    { $$ = makeNode("EXP",NULL, $1); }    |

        CALL            					                    { $$ = makeNode("EXP",NULL, $1); }    ;

        
NUM:    integernum 						                        { $$ = makeNode("NUM",NULL, $1); }  |

        realnum    						                        { $$ = makeNode("NUM",NULL, $1); }  ;
        
        CALL: id tk_lp CALL_ARGS tk_rp ACTIVATE_SCOPES  		{
                                                                $$ = makeNode("CALL",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5); }    ;

ACTIVATE_SCOPES:    tk_dot tk_activate tk_lp SCOPES_LIST tk_rp  {$$ = makeNode("ACTIVATE_SCOPES",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);
                                                                concatList($1, $4);
                                                                concatList($1, $5);}    |
                                                                {$$ = makeNode("ACTIVATE_SCOPES",NULL,makeNode("EPSILON",NULL, NULL));};

SCOPES_LIST:    SCOPES_LIST tk_comma integernum     		    {$$ = makeNode("SCOPES_LIST",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);}    |
                integernum                          		    {$$ = makeNode("SCOPES_LIST",NULL, $1);}    ;

CALL_ARGS:  CALL_ARGLIST    					                {$$ = makeNode("CALL_ARGS",NULL, $1);}    |
                            					                {$$ = makeNode("CALL_ARGS",NULL,makeNode("EPSILON",NULL, NULL));};
            
CALL_ARGLIST:   CALL_ARGLIST tk_comma EXP    			        {$$ = makeNode("CALL_ARGLIST",NULL, $1);
                                                                concatList($1, $2);
                                                                concatList($1, $3);}    |
                EXP                          			        {$$ = makeNode("CALL_ARGLIST",NULL, $1);}    ;

N:              						                        { $$.nextlist = commands->makelist(commands->nextquad()) ; emit("goto ") };

M:              						                        { $$.quad = commands->nextquad }




%%


void yyerror(char const * message)
{
    printf("Syntax error: '%s' in line number %d\n",yytext,yylineno);
    exit(2);
}
